int current_function;
void mode2_paint(void)
{
	char buf[32];
	unsigned int colors[5];
	paint_pad();
	rect(pbuf,WINW,WINH,WINH,0,WINW-WINH,WINH,0xc0c0c0);
	int x,y;
	char *str;
	str=levels[current_level-1].desc;
	x=WINH+104;
	y=52;
	strcpy(buf,"Level ");
	sprinti(buf,current_level,1);
	p_str(buf,strlen(buf),WINH+104,4,0x009090,pbuf,WINW,WINH);
	p_str("Press ESC to quit",17,WINH+104,20,0x009090,pbuf,WINW,WINH);
	p_str("Requirement:",12,WINH+104,36,0x009090,pbuf,WINW,WINH);
	while(*str)
	{
		if(*str=='\n')
		{
			x=WINH+104;
			y+=16;
		}
		else
		{
			p_char(*str,x,y,0x0000c0,pbuf,WINW,WINH);
			x+=8;
		}
		++str;
	}
	colors[0]=0xff0000;
	colors[1]=0xff0000;
	colors[2]=0xff0000;
	colors[3]=0xff0000;
	colors[4]=0xff0000;
	colors[current_function]=0x00ffff;
	rect(pbuf,WINW,WINH,WINH+4,4,48,24,colors[0]);
	p_str("Point",5,WINH+8,8,0xffffff,pbuf,WINW,WINH);
	rect(pbuf,WINW,WINH,WINH+4,36,40,24,colors[1]);
	p_str("Line",4,WINH+8,40,0xffffff,pbuf,WINW,WINH);
	rect(pbuf,WINW,WINH,WINH+4,68,56,24,colors[2]);
	p_str("Circle",6,WINH+8,72,0xffffff,pbuf,WINW,WINH);
	rect(pbuf,WINW,WINH,WINH+4,100,48,24,colors[3]);
	p_str("Erase",5,WINH+8,104,0xffffff,pbuf,WINW,WINH);
	rect(pbuf,WINW,WINH,WINH+4,132,48,24,colors[4]);
	p_str("Label",5,WINH+8,136,0xffffff,pbuf,WINW,WINH);
	if(levels[current_level-1].check())
	{
		rect(pbuf,WINW,WINH,WINH+4,164,24,24,0xff0000);
		p_str("OK",2,WINH+8,168,0xffffff,pbuf,WINW,WINH);
	}
	else
	{
		rect(pbuf,WINW,WINH,WINH+4,164,24,24,0x606060);
		p_str("OK",2,WINH+8,168,0xc0c0c0,pbuf,WINW,WINH);
	}
}
struct point *points_selected[2];
void unselect_points(void)
{
	if(points_selected[0])
	{
		points_selected[0]->color=0xff0000;
		points_selected[0]=NULL;
	}
	if(points_selected[1])
	{
		points_selected[1]->color=0xff0000;
		points_selected[1]=NULL;
	}
}
void mode2_pad_click(double x,double y)
{
	struct point *p,*nearest_p[2];
	struct line *l,*nearest_l[2];
	struct circle *c,*nearest_c[2];
	double dist,dist2,d;
	int i1,i2;
	nearest_p[0]=NULL;
	nearest_p[1]=NULL;
	nearest_l[0]=NULL;
	nearest_l[1]=NULL;
	nearest_c[0]=NULL;
	nearest_c[1]=NULL;
	p=point_list;
	dist=12.0;
	dist2=12.0;
	while(p)
	{
		d=distance(p->x,p->y,x,y);
		if(d<=dist)
		{
			dist2=dist;
			dist=d;
			nearest_p[1]=nearest_p[0];
			nearest_p[0]=p;
		}
		else if(d<=dist2)
		{
			dist2=d;
			nearest_p[1]=p;
		}
		p=p->next;
	}
	l=line_list;
	dist=12.0;
	dist2=12.0;
	while(l)
	{
		d=distance_to_line(l,x,y);
		if(d<=dist)
		{
			dist2=dist;
			dist=d;
			nearest_l[1]=nearest_l[0];
			nearest_l[0]=l;
		}
		else if(d<=dist2)
		{
			dist2=d;
			nearest_l[1]=l;
		}
		l=l->next;
	}
	c=circle_list;
	dist=12.0;
	dist2=12.0;
	while(c)
	{
		d=distance_to_circle(c,x,y);
		if(d<=dist)
		{
			dist2=dist;
			dist=d;
			nearest_c[1]=nearest_c[0];
			nearest_c[0]=c;
		}
		else if(d<=dist2)
		{
			dist2=d;
			nearest_c[1]=c;
		}
		c=c->next;
	}
	i1=-1;
	i2=-1;
	dist=18.0;
	dist2=18.0;
	if(nearest_l[0])
	{
		d=distance_to_line(nearest_l[0],x,y);
		if(d<=dist)
		{
			i1=0;
			dist=d;
		}
	}
	if(nearest_l[1])
	{
		d=distance_to_line(nearest_l[1],x,y);
		if(d<=dist)
		{
			i2=i1;
			i1=1;
			dist2=dist;
			dist=d;
		}
		else if(d<=dist2)
		{
			i2=1;
			dist2=d;
		}
	}
	if(nearest_c[0])
	{
		d=distance_to_circle(nearest_c[0],x,y);
		if(d<=dist)
		{
			i2=i1;
			i1=2;
			dist2=dist;
			dist=d;
		}
		else if(d<=dist2)
		{
			i2=2;
			dist2=d;
		}
	}
	if(nearest_c[1])
	{
		d=distance_to_circle(nearest_c[1],x,y);
		if(d<=dist)
		{
			i2=i1;
			i1=3;
			dist2=dist;
			dist=d;
		}
		else if(d<=dist2)
		{
			i2=3;
			dist2=d;
		}
	}
	if(current_function==0)
	{
		if(i1>i2)
		{
			int t;
			t=i1;
			i1=i2;
			i2=t;
		}
		if(i1!=-1)
		{
			double x_buf[2],y_buf[2];
			int count;
			if(i2<2)
			{
				if(intersection_ll(nearest_l[0],nearest_l[1],x_buf,y_buf)==0)
				{
					return;
				}
				add_point(x_buf[0],y_buf[0],1,0);
				InvalidateRect(hwnd,NULL,0);
				return;
			}
			else if(i1>=2)
			{
				count=intersection_cc(nearest_c[0],nearest_c[1],x_buf,y_buf);
				if(count==0)
				{
					return;
				}
				if(count==1)
				{
					add_point(x_buf[0],y_buf[0],1,0);
					InvalidateRect(hwnd,NULL,0);
					return;
				}
				dist=distance(x_buf[0],y_buf[0],x,y);
				d=distance(x_buf[1],y_buf[1],x,y);
				if(d<dist)
				{
					add_point(x_buf[1],y_buf[1],1,0);
					InvalidateRect(hwnd,NULL,0);
					return;
				}
				add_point(x_buf[0],y_buf[0],1,0);
				InvalidateRect(hwnd,NULL,0);
				return;
			}
			else
			{
				count=intersection_lc(nearest_l[0],nearest_c[0],x_buf,y_buf);
				if(count==0)
				{
					return;
				}
				if(count==1)
				{
					add_point(x_buf[0],y_buf[0],1,0);
					InvalidateRect(hwnd,NULL,0);
					return;
				}
				dist=distance(x_buf[0],y_buf[0],x,y);
				d=distance(x_buf[1],y_buf[1],x,y);
				if(d<dist)
				{
					add_point(x_buf[1],y_buf[1],1,0);
					InvalidateRect(hwnd,NULL,0);
					return;
				}
				add_point(x_buf[0],y_buf[0],1,0);
				InvalidateRect(hwnd,NULL,0);
				return;
			}
		}
		else if(i2==-1)
		{
			add_point(x,y,1,0);
			InvalidateRect(hwnd,NULL,0);
			return;
		}
		else if(i2<2)
		{
			double vx1,vy1,vx2,vy2,scale;
			vx1=x-nearest_l[0]->x1;
			vy1=y-nearest_l[0]->y1;
			vx2=nearest_l[0]->x2-nearest_l[0]->x1;
			vy2=nearest_l[0]->y2-nearest_l[0]->y1;
			scale=(vx1*vx2+vy1*vy2)/(vx2*vx2+vy2*vy2);
			add_point(nearest_l[0]->x1+vx2*scale,nearest_l[0]->y1+vy2*scale,1,0);
			InvalidateRect(hwnd,NULL,0);
			return;
		}
		else
		{
			d=distance(nearest_c[0]->x,nearest_c[0]->y,x,y);
			if(IS_ZERO(d))
			{
				return;
			}
			add_point(nearest_c[0]->x+(x-nearest_c[0]->x)*nearest_c[0]->r/d
			,nearest_c[0]->y+(y-nearest_c[0]->y)*nearest_c[0]->r/d,1,0);
			InvalidateRect(hwnd,NULL,0);
			return;
		}
	}
	else if(current_function==1)
	{
		if(nearest_p[0]==NULL)
		{
			unselect_points();
			InvalidateRect(hwnd,NULL,0);
			return;
		}
		if(points_selected[0])
		{
			add_line(nearest_p[0]->x,nearest_p[0]->y,points_selected[0]->x,points_selected[0]->y,1);
			unselect_points();
			InvalidateRect(hwnd,NULL,0);
			return;
		}
		points_selected[0]=nearest_p[0];
		points_selected[0]->color=0x00c0ff;
		InvalidateRect(hwnd,NULL,0);
	}
	else if(current_function==2)
	{
		if(nearest_p[0]==NULL)
		{
			unselect_points();
			InvalidateRect(hwnd,NULL,0);
			return;
		}
		if(points_selected[1])
		{
			d=distance(points_selected[0]->x,points_selected[0]->y,
			points_selected[1]->x,points_selected[1]->y);
			add_circle(nearest_p[0]->x,nearest_p[0]->y,d,1);
			unselect_points();
			InvalidateRect(hwnd,NULL,0);
			return;
		}
		if(points_selected[0])
		{
			points_selected[1]=nearest_p[0];
			points_selected[1]->color=0x00c0ff;
			InvalidateRect(hwnd,NULL,0);
			return;
		}
		points_selected[0]=nearest_p[0];
		points_selected[0]->color=0x00c0ff;
		InvalidateRect(hwnd,NULL,0);
	}
	else if(current_function==3)
	{
		if(nearest_p[0]&&nearest_p[0]->can_erase)
		{
			p=point_list;
			if(p==nearest_p[0])
			{
				point_list=p->next;
			}
			else
			{
				while(p->next!=nearest_p[0])
				{
					p=p->next;
				}
				p->next=p->next->next;
			}
			free(nearest_p[0]);
			InvalidateRect(hwnd,NULL,0);
			return;
		}
		if(nearest_l[0]&&nearest_l[0]->can_erase&&i1<2)
		{
			l=line_list;
			if(l==nearest_l[0])
			{
				line_list=l->next;
			}
			else
			{
				while(l->next!=nearest_l[0])
				{
					l=l->next;
				}
				l->next=l->next->next;
			}
			free(nearest_l[0]);
			InvalidateRect(hwnd,NULL,0);
			return;
		}
		if(nearest_c[0]&&nearest_c[0]->can_erase&&i1>=2)
		{
			c=circle_list;
			if(c==nearest_c[0])
			{
				circle_list=c->next;
			}
			else
			{
				while(c->next!=nearest_c[0])
				{
					c=c->next;
				}
				c->next=c->next->next;
			}
			free(nearest_c[0]);
			InvalidateRect(hwnd,NULL,0);
			return;
		}
	}
	else if(current_function==4)
	{
		if(nearest_p[0]&&nearest_p[0]->can_erase)
		{
			points_selected[0]=nearest_p[0];
			points_selected[0]->color=0x00c0ff;
		}
		else
		{
			unselect_points();
		}
		InvalidateRect(hwnd,NULL,0);
	}
}
void mode2_click(int X,int Y)
{
	if(X>=WINH)
	{
		unselect_points();
		int x,y;
		y=4;
		if(X>=WINH+4)
		{
			x=X-(WINH+4);
			if(x<48&&Y>=y&&Y<y+24)
			{
				current_function=0;		
				InvalidateRect(hwnd,NULL,0);
			}
			y+=32;
			if(x<40&&Y>=y&&Y<y+24)
			{
				current_function=1;
				InvalidateRect(hwnd,NULL,0);
			}
			y+=32;
			if(x<56&&Y>=y&&Y<y+24)
			{
				current_function=2;
				InvalidateRect(hwnd,NULL,0);
			}
			y+=32;
			if(x<48&&Y>=y&&Y<y+24)
			{
				current_function=3;
				InvalidateRect(hwnd,NULL,0);
			}
			y+=32;
			if(x<48&&Y>=y&&Y<y+24)
			{
				current_function=4;
				InvalidateRect(hwnd,NULL,0);
			}
			y+=32;
			if(x<24&&Y>=y&&Y<y+24)
			{
				if(levels[current_level-1].check())
				{
					++current_level;
					if(current_level<=count_levels)
					{
						mode2_init();
					}
					else
					{
						mode=1;
					}
					InvalidateRect(hwnd,NULL,0);
				}
			}
		}
	}
	else
	{
		mode2_pad_click((double)X,(double)Y);
	}
}
void mode2_key(int keycode)
{
	if(keycode==27) // ESC
	{
		mode=1;
		InvalidateRect(hwnd,NULL,0);
	}
	if(keycode>='A'&&keycode<='Z')
	{
		if(current_function==4&&points_selected[0]&&!point_by_label(keycode))
		{
			points_selected[0]->label=keycode;
			unselect_points();
			InvalidateRect(hwnd,NULL,0);
		}
	}
}
void mode2_init(void)
{
	clear_pad();
	levels[current_level-1].init();
	current_function=0;
	memset(points_selected,0,sizeof(points_selected));
}